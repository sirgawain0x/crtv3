name: pipeline-metokens-subscribes-turbo
resource_size: m
description: Turbo pipeline that reads Subscribe events directly from Base blockchain, bypassing the subgraph. Processes all historical Subscribe events from the MeToken Diamond contract and writes to Supabase.

sources:
  base_logs:
    type: dataset
    dataset_name: base.raw_logs
    version: 1.0.0
    start_at: earliest

transforms:
  # Filter to logs from Diamond contract and Subscribe events
  # Filter by event signature hash (topic[1]) before decoding to avoid struct field access issues
  subscribe_logs:
    type: sql
    primary_key: id
    sql: |
      SELECT
        id,
        address,
        topics,
        data,
        block_number,
        block_timestamp,
        transaction_hash,
        log_index,
        _gs_op
      FROM base_logs
      WHERE
        -- Diamond contract address on Base
        address = lower('0xba5502db2aC2cBff189965e991C07109B14eB3f5')
        -- Filter by Subscribe event signature: Subscribe(address,address,uint256,address,uint256,string,string,uint256)
        -- topics is a comma-separated string, so use LIKE to match the first topic (event signature hash)
        AND topics LIKE _gs_keccak256('Subscribe(address,address,uint256,address,uint256,string,string,uint256)') || '%'

  # Decode Subscribe events using ABI
  # Only Subscribe events reach here due to signature filtering above
  # Convert topics string to array for _gs_log_decode
  decoded_subscribes:
    type: sql
    primary_key: id
    sql: |
      SELECT
        id,
        address,
        _gs_log_decode(
          '[{
            "anonymous": false,
            "inputs": [
              {"indexed": true, "name": "meToken", "type": "address"},
              {"indexed": true, "name": "owner", "type": "address"},
              {"indexed": false, "name": "minted", "type": "uint256"},
              {"indexed": false, "name": "asset", "type": "address"},
              {"indexed": false, "name": "assetsDeposited", "type": "uint256"},
              {"indexed": false, "name": "name", "type": "string"},
              {"indexed": false, "name": "symbol", "type": "string"},
              {"indexed": false, "name": "hubId", "type": "uint256"}
            ],
            "name": "Subscribe",
            "type": "event"
          }]',
          string_to_array(topics, ','),
          data
        ) as decoded,
        block_number,
        block_timestamp,
        transaction_hash,
        log_index,
        _gs_op
      FROM subscribe_logs

  # Filter to only successfully decoded Subscribe events
  # No need to check decoded.name since we already filtered by signature
  filtered_subscribes:
    type: sql
    primary_key: id
    sql: |
      SELECT
        id,
        address,
        decoded,
        block_number,
        block_timestamp,
        transaction_hash,
        log_index,
        _gs_op
      FROM decoded_subscribes
      WHERE decoded IS NOT NULL

  # Extract and clean decoded parameters with TypeScript transform
  # Output format matches existing Supabase schema (hex strings for bytea columns)
  clean_subscribes:
    type: script
    from: filtered_subscribes
    language: typescript
    primary_key: id
    schema:
      id: string
      me_token: string
      owner: string
      hub_id: string
      assets_deposited: string
      minted: string
      asset: string
      name: string
      symbol: string
      block_timestamp: float64
      block_number: int64
      transaction_hash: string
      block: int64
    script: |
      interface DecodedSubscribe {
        id: string;
        address: string;
        decoded?: {
          name: string;
          event_params: string[]; // Array of string values (not objects)
        };
        block_number: number;
        block_timestamp: number;
        transaction_hash: string;
        log_index: number;
      }

      function invoke(data: DecodedSubscribe): {
        id: string;
        me_token: string;
        owner: string;
        hub_id: string;
        assets_deposited: string;
        minted: string;
        asset: string;
        name: string;
        symbol: string;
        block_timestamp: number;
        block_number: number;
        transaction_hash: string;
        block: number;
      } | null {
        // Filter out records where decoding failed
        if (!data.decoded || !data.decoded.event_params || !Array.isArray(data.decoded.event_params)) {
          return null;
        }

        const params = data.decoded.event_params;
        
        // Extract parameters by index (order matches ABI)
        // According to _gs_log_decode documentation, event_params is LIST<VARCHAR>
        // All parameters (indexed and non-indexed) are included in order:
        // meToken (indexed, address) = params[0] in TypeScript (1-indexed in SQL)
        // owner (indexed, address) = params[1] in TypeScript (2-indexed in SQL)
        // minted (uint256) = params[2] in TypeScript (3-indexed in SQL)
        // asset (address) = params[3] in TypeScript (4-indexed in SQL)
        // assetsDeposited (uint256) = params[4] in TypeScript (5-indexed in SQL)
        // name (string) = params[5] in TypeScript (6-indexed in SQL)
        // symbol (string) = params[6] in TypeScript (7-indexed in SQL)
        // hubId (uint256) = params[7] in TypeScript (8-indexed in SQL)
        const meToken = (params[0] || '').toString().toLowerCase();
        const owner = (params[1] || '').toString().toLowerCase();
        const minted = (params[2] || '0').toString();
        const asset = (params[3] || '').toString().toLowerCase();
        const assetsDeposited = (params[4] || '0').toString();
        const name = (params[5] || '').toString();
        const symbol = (params[6] || '').toString();
        const hubId = (params[7] || '0').toString();

        // Validate required fields
        if (!meToken || !owner || !data.transaction_hash) {
          return null;
        }

        // Format hex strings for PostgreSQL bytea: '\x' + hex without '0x' prefix
        // PostgreSQL accepts bytea in this format
        const formatBytea = (hex: string): string => {
          if (!hex || !hex.startsWith('0x')) return hex;
          return '\\x' + hex.substring(2);
        };

        // ID is transaction_hash (one Subscribe event per transaction)
        const txHash = data.transaction_hash.toLowerCase();

        return {
          id: formatBytea(txHash), // Format for PostgreSQL bytea
          me_token: formatBytea(meToken),
          owner: formatBytea(owner),
          hub_id: hubId,
          assets_deposited: assetsDeposited,
          minted: minted,
          asset: formatBytea(asset),
          name: name,
          symbol: symbol,
          block_timestamp: data.block_timestamp, // Unix timestamp (numeric)
          block_number: data.block_number,
          transaction_hash: formatBytea(txHash),
          block: data.block_number, // Integer block number
        };
      }

sinks:
  postgres_metoken_subscribes:
    type: postgres
    from: clean_subscribes
    schema: public
    table: metoken_subscribes
    secret_name: POSTGRES_SECRET_CMJIQCIFZ0
    primary_key: id
