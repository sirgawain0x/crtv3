import crypto from "node:crypto";
import { BaseError } from '../internal/errors.js';
import { BigIntSerializationError, CheckConstraintError, DbConnectionError, NonRetryableUserError, NotNullConstraintError, ShutdownError, UniqueConstraintError, } from '../internal/errors.js';
import { startClock } from '../utils/timer.js';
import { wait } from '../utils/wait.js';
import { PGlite } from "@electric-sql/pglite";
const RETRY_COUNT = 9;
const BASE_DURATION = 125;
export const parseDbError = (error) => {
    const stack = error.stack;
    if (error instanceof BaseError) {
        return error;
    }
    if (error?.message?.includes("violates not-null constraint")) {
        error = new NotNullConstraintError(error.message);
    }
    else if (error?.message?.includes("violates unique constraint")) {
        error = new UniqueConstraintError(error.message);
    }
    else if (error?.message?.includes("violates check constraint")) {
        error = new CheckConstraintError(error.message);
    }
    else if (error?.message?.includes("Do not know how to serialize a BigInt")) {
        error = new BigIntSerializationError(error.message);
        error.meta.push("Hint:\n  The JSON column type does not support BigInt values. Use the replaceBigInts() helper function before inserting into the database. Docs: https://ponder.sh/docs/api-reference/ponder-utils#replacebigints");
    }
    else if (error?.message?.includes("does not exist")) {
        error = new NonRetryableUserError(error.message);
    }
    else if (error?.message?.includes("already exists")) {
        error = new NonRetryableUserError(error.message);
    }
    else if (error?.message?.includes("terminating connection due to administrator command") ||
        error?.message?.includes("connection to client lost") ||
        error?.message?.includes("too many clients already") ||
        error?.message?.includes("Connection terminated unexpectedly") ||
        error?.message?.includes("ECONNRESET") ||
        error?.message?.includes("ETIMEDOUT") ||
        error?.message?.includes("timeout exceeded when trying to connect")) {
        error = new DbConnectionError(error.message);
    }
    error.stack = stack;
    return error;
};
/**
 * Create a query builder.
 *
 * @example
 * ```ts
 * const qb = createQB(drizzle(pool), { casing: "snake_case", common });
 * const result1 = await qb.wrap((db) => db.select().from(accounts));
 * const result2 = await qb.wrap({ label: "label" }, (db) => db.select().from(accounts));
 * ```
 */
export const createQB = (db, { common, isAdmin }) => {
    const dialect = db.$client instanceof PGlite ? "pglite" : "postgres";
    // Retry, logging, metrics, and error parsing wrapper
    const retryLogMetricErrorWrap = async (fn, { label, isTransaction, isTransactionStatement, logger, }) => {
        // First error thrown is often the most useful
        let firstError;
        let hasError = false;
        for (let i = 0; i <= RETRY_COUNT; i++) {
            const endClock = startClock();
            const id = crypto.randomUUID().slice(0, 8);
            if (label) {
                logger.trace({
                    msg: "Started database query",
                    query: label,
                    query_id: id,
                });
            }
            try {
                if (common.shutdown.isKilled && isAdmin === false) {
                    throw new ShutdownError();
                }
                const result = await fn();
                if (label) {
                    common.metrics.ponder_database_method_duration.observe({ method: label }, endClock());
                }
                if (label) {
                    logger.trace({
                        msg: "Completed database query",
                        query: label,
                        query_id: id,
                        duration: endClock(),
                    });
                }
                return result;
            }
            catch (e) {
                const error = parseDbError(e);
                if (common.shutdown.isKilled) {
                    throw new ShutdownError();
                }
                if (label) {
                    common.metrics.ponder_database_method_duration.observe({ method: label }, endClock());
                    common.metrics.ponder_database_method_error_total.inc({
                        method: label,
                    });
                }
                if (!hasError) {
                    hasError = true;
                    firstError = error;
                }
                // Two types of transaction environments
                // 1. Inside callback (running user statements or control flow statements): Throw error, retry
                // later. We want the error bubbled up out of the callback, so the transaction is properly rolled back.
                // 2. Outside callback (running entire transaction, user statements + control flow statements): Retry immediately.
                if (isTransaction) {
                    if (error instanceof NonRetryableUserError) {
                        throw error;
                    }
                }
                else if (isTransactionStatement) {
                    // Transaction statements are not immediately retried, so the transaction will be properly rolled back.
                    logger.warn({
                        msg: "Failed database query",
                        query: label,
                        query_id: id,
                        duration: endClock(),
                        error,
                    });
                    throw error;
                }
                else if (error instanceof NonRetryableUserError) {
                    logger.warn({
                        msg: "Failed database query",
                        query: label,
                        query_id: id,
                        duration: endClock(),
                        error,
                    });
                    throw error;
                }
                if (i === RETRY_COUNT) {
                    logger.warn({
                        msg: "Failed database query",
                        query: label,
                        query_id: id,
                        retry_count: i,
                        duration: endClock(),
                        error,
                    });
                    throw firstError;
                }
                const duration = BASE_DURATION * 2 ** i;
                logger.warn({
                    msg: "Failed database query",
                    query: label,
                    query_id: id,
                    retry_count: i,
                    retry_delay: duration,
                    duration: endClock(),
                    error,
                });
                await wait(duration);
            }
        }
        throw "unreachable";
    };
    // Add QB methods to the transaction object
    const addQBMethods = (db) => {
        const _transaction = db.transaction.bind(db);
        // @ts-ignore
        db.transaction = async (...args) => {
            if (typeof args[0] === "function") {
                const [callback, config, transactionContext] = args;
                // Note: We want to retry errors from `callback` but include
                // the transaction control statements in `_transaction`.
                return retryLogMetricErrorWrap(() => _transaction(async (tx) => {
                    addQBMethods(tx);
                    // @ts-expect-error
                    tx.raw = tx;
                    Object.assign(tx, { $dialect: dialect });
                    // @ts-expect-error
                    Object.assign(tx, { $client: tx.session.client });
                    // Note: `tx.wrap` should not retry errors, because the transaction will be aborted
                    // @ts-ignore
                    tx.wrap = (...args) => {
                        if (typeof args[0] === "function") {
                            const [query, context] = args;
                            return retryLogMetricErrorWrap(async () => query(tx), {
                                isTransaction: false,
                                isTransactionStatement: true,
                                logger: context?.logger ??
                                    transactionContext?.logger ??
                                    common.logger,
                            });
                        }
                        else {
                            const [{ label }, query, context] = args;
                            return retryLogMetricErrorWrap(async () => query(tx), {
                                label,
                                isTransaction: false,
                                isTransactionStatement: true,
                                logger: context?.logger ??
                                    transactionContext?.logger ??
                                    common.logger,
                            });
                        }
                    };
                    const result = await callback(tx);
                    return result;
                }, config), {
                    isTransaction: true,
                    isTransactionStatement: false,
                    logger: transactionContext?.logger ?? common.logger,
                });
            }
            else {
                const [{ label }, callback, config, transactionContext] = args;
                // Note: We want to retry errors from `callback` but include
                // the transaction control statements in `_transaction`.
                return retryLogMetricErrorWrap(() => _transaction(async (tx) => {
                    addQBMethods(tx);
                    // @ts-expect-error
                    tx.raw = tx;
                    Object.assign(tx, { $dialect: dialect });
                    // @ts-expect-error
                    Object.assign(tx, { $client: tx.session.client });
                    // Note: `tx.wrap` should not retry errors, because the transaction will be aborted
                    // @ts-ignore
                    tx.wrap = (...args) => {
                        if (typeof args[0] === "function") {
                            const [query, context] = args;
                            return retryLogMetricErrorWrap(async () => query(tx), {
                                label,
                                isTransaction: false,
                                isTransactionStatement: true,
                                logger: context?.logger ??
                                    transactionContext?.logger ??
                                    common.logger,
                            });
                        }
                        else {
                            const [{ label }, query, context] = args;
                            return retryLogMetricErrorWrap(async () => query(tx), {
                                label,
                                isTransaction: false,
                                isTransactionStatement: true,
                                logger: context?.logger ??
                                    transactionContext?.logger ??
                                    common.logger,
                            });
                        }
                    };
                    const result = await callback(tx);
                    return result;
                }, config), {
                    label,
                    isTransaction: true,
                    isTransactionStatement: false,
                    logger: transactionContext?.logger ?? common.logger,
                });
            }
        };
    };
    if (dialect === "postgres") {
        addQBMethods(db);
    }
    else {
        // @ts-ignore
        db.transaction = async (...args) => {
            if (typeof args[0] === "function") {
                const [callback, context] = args;
                // @ts-expect-error
                return retryLogMetricErrorWrap(() => callback(db), {
                    isTransactionStatement: true,
                    logger: context?.logger ?? common.logger,
                });
            }
            else {
                const [{ label }, callback, context] = args;
                // @ts-expect-error
                return retryLogMetricErrorWrap(() => callback(db), {
                    label,
                    isTransactionStatement: true,
                    logger: context?.logger ?? common.logger,
                });
            }
        };
    }
    const qb = db;
    qb.raw = db;
    qb.$dialect = dialect;
    qb.$client = db.$client;
    qb.wrap = async (...args) => {
        if (typeof args[0] === "function") {
            const [query, context] = args;
            // @ts-expect-error
            return retryLogMetricErrorWrap(() => query(qb), {
                isTransactionStatement: false,
                // @ts-expect-error
                logger: context?.logger ?? common.logger,
            });
        }
        else {
            const [{ label }, query, context] = args;
            // @ts-expect-error
            return retryLogMetricErrorWrap(() => query(qb), {
                isTransactionStatement: false,
                label,
                // @ts-expect-error
                logger: context?.logger ?? common.logger,
            });
        }
    };
    return qb;
};
//# sourceMappingURL=queryBuilder.js.map